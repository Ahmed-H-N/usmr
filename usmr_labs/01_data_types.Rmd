```{r}
SHOW_SOLS = TRUE
```


# Types of data {#chap-data-types}

:::frame
## Pre-requisites {-}  
  
Please ensure you have successfully installed R and RStudio, or are working on RStudioCloud, and that you have completed the tasks on the [Introduction to R page - Included as the previous Chapter of this book](#chap-intro), which illustrated the basics of a) how to create a Rmarkdown document, b) how to read data into R, and c) how to use R to do basic arithmetic.  

::: 

In this chapter, we are going to take a look at how to access specific sections of data, before we move on to talking about different types of data.  
  
We encourage you to work along with the reading - open a new RMarkdown document, and run the code which we discuss below.  
   
At the end of the chapter, there is a set of exercises for you to complete. 
  
:::lo
## Learning Objectives {-}

+ LO1: Learn how to access entries within data stored in R  
+ LO2: Learn how to modify entries/variables in data   
+ LO3: Understand the distinction between types of variable and how to code data as different types (classes) in R  

:::

## Accessing subsections of data  

Suppose we read some data in to R:
```{r message=FALSE}
library(tidyverse)

starwars<-dplyr::starwars %>% select(-mass, -skin_color, -films, -vehicles,-starships, -gender,-birth_year)
starwars[87,]<-c("Homer Simpson",180,NA,NA,"Springfield","unknown")
starwars[40,]<-c("Marge Simpson",170,"Blue",NA,"Springfield","unknown")
starwars[2,"species"]<-"Human"
starwars[7,"height"]<-9420
starwars$height<-as.numeric(starwars$height)
starwars<-starwars %>% filter(!is.na(homeworld),!is.na(species))
```

:::yellow
__Reading data from the internet__ 

Note that when you have a url for some data, such as [link](url), you can read it in directly by giving functions like `read_csv()` the url inside quotation marks. 
:::

We can print out the top of the data by using the name we just gave it:  
```{r}
starwars
```
_(Don't worry about the_ NAs _for now, they are just how R tells you an entry is missing)_  
The data contains information on various characteristics of characters from Star Wars. 

:::green
__Tip:__ Try clicking on the data in your __environment__ (the top right window of Rstudio). It will open the data in a tab in the editor window - this is another way of looking at the data, more like you would in spreadsheet software like Microsoft Excel. 
:::

We can take a look at how big the data is (the dimensions), using `dim()`
```{r}
dim(starwars)
```
There's a reasonable amount of data in there - `r nrow(starwars)` rows and `r ncol(starwars)` variables (columns). What if we want to extract certain bits of it?  

This is where we learn about two important bits of R code used to access parts of data - the dollar sign `$`, and the square brackets `[]`.

#### The dollar sign $ {-}

The dollar sign allows us to select a specific variable.  
For instance, we can pull out the variable named "eye_color" in the data, by using `$eye_color` after the name that we gave our dataset: 
```{r}
starwars$eye_color
```

#### The square brackets [] {-}

Square brackets are used to do what is known as __indexing__ (finding specific entries in your data).  

We can retrieve bits of data by identifying the $i^{th}$ entry(s) inside the square brackets, for instance: 

```{r}
somevalues <- c(10,20,30,40,50,60,70,80,90,100)

# pull out the 3rd entry
somevalues[3]
```

In the above example, we have a __vector__ (a single sequence of values), and so we can retrieve entries with the syntax:  
&nbsp;&nbsp; _vector[entry]_  
  
  
In a __dataframe__ we have an extra dimension - we have _rows_ __and__ _columns_. 
Using square brackets with a dataframe needs us to specify both:  
&nbsp;&nbsp; _dataframe[rows, columns]_  

For instance:
```{r}
# first row, fourth column:
starwars[1,4]

# tenth row, first column:
starwars[10,1]
```

If we leave either rows or columns blank, then we will get out _all_ of them: 
```{r}
# tenth row, all columns:
starwars[10, ]

# all rows, 2nd column:
starwars[ , 2]
```

There are is another way to identify column - we can use the name in quotation marks:
```{r}
# first row, "species" column
starwars[1, "species"]
```

Finally, we can also ask for multiple rows, or multiple columns, or both!
```{r}
# the 1st AND the 6th row, 
# and the 1st AND 3rd columns:
starwars[c(1,6), c(1,3)]
```

And we can specify a sequence using the colon, `from:to`:  
```{r}
# FROM the 1st TO the 6th row, all columns:
starwars[1:6, ]
```

`r optbegin(label="Extra", slabel=FALSE)`
We can use the two accessors in combination: 

```{r}
# extract the variable called "name" and show the 20th entry 
starwars$name[20]
```

__Note:__ When we do this, we don't have the comma inside the square brackets.  
When we use the `$` to pull out a variable, such as `starwars$name`, we no longer have a dataframe - `starwars$name` doesn't have rows and columns, it just has a series of values - _it's a vector!_.   
So when you are using `[]` with a __vector__ (1 dimension) rather than a __dataframe__ (2 dimensions), you don't specify `[rows, columns]`, but simply `[entry]`. 
`r optend()`



:::yellow
#### Accessors {-}

__The dollar sign $__ 

Used to extract a variable from a dataframe:   

+ `dataframe$variable`

__The square brackets []__

Used to extract parts of an R object by identifying rows and/or columns, or more generally, "entries". Left blank will return all. 

+ `dataframe[rows, columns]`  
+ `vector[entries]`  

:::

### Accessing by a condition {-}

We can also do something really useful, which is to access all the entries in the data for which _a specific condition_ is true.  

Let's take a simple example to start:
```{r}
somevalues <- c(10,10,0,20,15,40,10,40,50,35)
```

If we want to access all the values which are >20, we can use:
```{r}
somevalues[somevalues>20]
```

Let's unpack what this is doing.. 
First, let's look at what `somevalues>20` does:
```{r}
somevalues>20
```

It gives us `FALSE` for the entries of `somevalues` which are less than (or equal to) 20, and TRUE for the entries which are greater. 
This statement `>20` is the __condition__.  
  
Now consider the following, where we have taken that set of TRUE/FALSE's and put them inside the square brackets:
```{r}
somevalues[c(FALSE,FALSE,FALSE,FALSE,FALSE,TRUE,FALSE,TRUE,TRUE,TRUE)]
```
It gives us out the entries of `somevalues` which we have specified are `TRUE`.  
This is the same as what our initial line was doing:
```{r}
somevalues[somevalues>20]
```

We can extend this same logic to a dataframe.  
Let's suppose we want to access all the entries in our Star Wars data who have the value "Droid" in the _species_ variable.  

To work out how to do this, we first need a line of code which defines our __condition__ - one which returns `TRUE` for each entry of the _species_ variable which is "Droid", and `FALSE` for those that are not "Droid".  

We can use the dollar sign to pull out the _species_ variable: 
```{r}
starwars$species
```

And we can ask R whether each value __is equal to__ "Droid".  

&nbsp;&nbsp; __Remember:__ in R, we ask whether something __is equal to__ something else by using a double-equals, `==`.

```{r}
starwars$species == "Droid"
```

  
Finally, we can use this list of TRUE/FALSEs inside our square brackets to access the entries of the data for which this condition is TRUE:
```{r}
# I would read the code below as: 

# "In the starwars dataframe, give me all the rows for which the
# condition starwars$species=="Droid" is TRUE, and give me all the columns."

starwars[starwars$species == "Droid", ]
```

---  

## Editing subsections of data  

Now that we've seen how to _access_ sections of data, we can learn how to edit them!  

:::yellow
__Data Cleaning__

One of the most common reasons you will need to edit entries in your data is in __data cleaning__. This is the process of identifying incorrect/incomplete/irrelevant data, and replacing/modifying/deleting them.  
:::

#### Modifying specific entries {-}

Above, we looked at the subsection of the data where the _species_ variable had the entry "Droid". Some of you may have noticed earlier that we had some data on C3PO. Is he not also a droid? 

![](images/types_of_data/c3po.png)  
(Looks pretty Droid-y to me! _disclaimer: I know nothing about Star Wars_ &#128578; )

Just as we saw above how to _access_ specific entries, e.g.: 
```{r}
# 2nd row, all columns
starwars[2, ]
# 2nd row, 6th column (the "species" column)
starwars[2,6]
```
We can change these by __assigning them a new value__ (remember the `<-` symbol):
```{r}
# C3PO is a droid, not a human
starwars[2,6]<-"Droid"

# Look at the 2nd row now -
# the entry in the "species" column has changed:
starwars[2, ]
```

:::frame
__think of it as "overwriting"__

We have _overwritten_ the entry in the 2nd row, 6th column of the data (`starwars[2,6]`) with the value "Droid".  
:::

#### Modifying entries based on a condition {-}

We saw above how we can access subsections of data based on a __condition__, with code such as:

```{r}
# "In the starwars dataframe, give me all the rows for which the
# condition starwars$homeworld=="Naboo" is TRUE, and give me all the columns."

# remember, we're asking for all the columns by leaving it blank *after* the 
# comma inside the square brackets: data[rows, columns]
starwars[starwars$homeworld=="Naboo", ]
```

What if we wanted to modify it so that every character from "Naboo" was actually of species "Nabooian"?  

We can do that in a number of ways, all of which do the same thing - namely, they access parts of the data and assign them the new value "Nabooian".  

Study the lines of code below and their interpretations:  

```{r}
# In the starwars data, give the rows for which condition starwars$homeworld=="Naboo" is TRUE, and give the "species" column. Assign these the value "Nabooian".
starwars[starwars$homeworld=="Naboo", "species"] <- "Nabooian"

# In the starwars data, give the rows for which condition starwars$homeworld=="Naboo" is TRUE, and give the 6th column. Assign these the value "Nabooian".
starwars[starwars$homeworld=="Naboo", 6] <- "Nabooian"

# In the species variable in the starwars data, give the entries for which condition starwars$homeworld=="Naboo" is TRUE. Assign these the value "Nabooian".
starwars$species[starwars$homeworld=="Naboo"] <- "Nabooian"
```

#### Changing a whole column {-}

Another thing we might want to do is change a whole column in some way.  
The logic is the same, for instance: 
```{r}
starwars$height <- starwars$height/100
```
What we have done above is assign the variable "height" inside the dataframe "starwars", and give it the values which we get from `starwars$height/100`.  

Equally, we _could also have a new_ column, called "height2" with these values:  
```{r eval=FALSE}
starwars$height2 <- starwars$height/100
```
This would have left the "height" variable as-is, and created a new one called "height2" which was the values in "height" divided by 100. 

#### Changing the shape of the data {-}  

Lastly, we might want to change the data by removing a row or a column.  
Again, the logic remains the same, in that we use `<-` to assign the edited data to a name (either a new name, thus creating a new object, or an existing name, thereby _overwriting_ that object).  
  
For instance, notice that the 40th and 87th rows of our data probably aren't a valid observation - I'm reasonably sure that Marge and Homer Simpson never appeared in Star Wars:
```{r}
starwars[c(40,87), ]
```


We can remove a certain row(s) by using a minus sign `-` inside the square brackets 
```{r}
# everything minus the 87th row
starwars[-87, ]

# everything minus the (40th and 87th rows)
starwars[-c(40, 87), ]
```

And we can simply _re-use_ the name "starwars" to overwrite the data and make this change take effect (rather than just print out the result, which the code above did):
```{r}
starwars <- starwars[-c(40,87), ]
```
(now, in the __environment__ pane of Rstudio, the object named "starwars" will say 85 observations, rather than 87, which it had before - we've removed the 2 rows)   

The same logic applies for columns:

```{r}
# Create a new object called "anonymous_starwars" and assign it 
# to the values which are the "starwars" dataset minus the 
# 1st column (the "name" column):
anonymous_starwars <- starwars[, -1]

# print out anonymous_starwars
anonymous_starwars
```

---

## Types of data 
          
There are so many different ways we can measure things, and so the data which results from our measurements vary also.  
For instance, we could measure the colour of people's hair as any of "black", "brown", "blond", and so on, or we could use reflective spectrophotometry to obtain a number for the black/white-ness, a number for the red/green-ness, and a number for the blue/yellow-ness. One approach gives us a set of possible categories, the other gives us numbers.  

          
|  __Type__|  __Description__|  __Example__|
|--:|--:|--:|
|  __Categorical__|  Variables with a discrete number of response options<br>Binary data is a special case with only 2 possible values|  Species: _Human_, _Droid_, _Wookie_, _Hutt_, ...<br>Is_Human: _Yes_, _No_.|
|  __Continuous__|  Variables which can take any real number value within the specified range of measurement|  Height: _172_, _165.2_, _183_, ... |
|  __Count__|  Variables which can only take non-negative integer values (0,1,2,3 etc.)|  Number_of_movies: _5_, _6_, _7_, _4_, _5_, ...|


In R, different types of data get treated differently by functions, and often we need to tell R explicitly what type of data each variable is. We can use some specific functions to both tell and ask R what type some data are:

|  __Type__|  __Set as...__|  __Check is...__|
|--:|--:|--:|
|  __Categorical__|  `as.factor()`<br>`factor()`|  `is.factor(variable)`|
|  __Continuous__|  `as.numeric()`|  `is.numeric(variable)`|
|  __Character__|  `as.character()`|  `is.character(variable)`|


We can check whether variables of a certain class by using functions such as:
```{r}
is.character(starwars$name)
is.numeric(starwars$height)
is.factor(starwars$species)
```

Alternatively, we can also use the function `class()`:
```{r}
class(starwars$height)
```

And we can modify the class of a variable by following the same syntax as we modified variables earlier, and using functions such as `as.factor()`, `as.numeric()`:
```{r}
# overwrite the "species" variable with a 'factorised' "species" variable:
starwars$species <- as.factor(starwars$species)
```

Check that it is now a factor:
```{r}
class(starwars$species)
```

Factors have certain __levels__ that values can take:  
```{r}
levels(starwars$species)
```
 
:::yellow
__Levels__  

In categorical data, each case has a value which is one of a fixed set of possibilities. The set of possibilities are the __levels__ of a categorical variable.  
:::

If we were to try and set an entry as a value which is not one of those levels, it won't work: 
```{r}
# set the 1st row, 6th column (the species variable) to be "Peppapig"
starwars[1, 6]<-"Peppapig"
```
<p style="color:red">invalid factor level, NA generated</p>  
  

One useful function which treats different classes of variable differently, is `summary()`.  
Notice how the output differs between variables such as _height_, which we know is numeric, _species_, which we just set to be categorical, and _homeworlds_ which is currently character (just text):  
```{r}
summary(starwars)
```

---  

## Exercises 


`r qbegin(1)`
Open a new Rmarkdown document.  

__File > New File > R Markdown..__
`r qend()`

---

`r qbegin(2)`
In your first code-chunk, load the _tidyverse_ packages with the following command: 
```{r eval=FALSE}
library(tidyverse)
```

Make sure you run the chunk. 
`r qend()`

---

For the exercises, we have a dataset on the most popular internet passwords, their strength, and how long it took for an algorithm to crack it.  

```{r}
pwords <- read_csv("https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2020/2020-01-14/passwords.csv")[1:500,] %>% select(rank, password, category, value, strength) %>%
    rename(cracked = "value", type="category")

tibble(
    variable = names(pwords),
    description = c("popularity in their database of released passwords",
                    "password","category of password","Time to crack by online guessing","Strength = quality of password where 10 is highest, 1 is lowest")
) %>% knitr::kable()
```

The data is available online at [link](link). 
  
If you click on that link, you will notice that the values are separated by commas. You may also notice that the url ends with __.csv__. This means we can use the `read_csv()` function to read it into R.  


`r qbegin()`
Read in the data from the link above.  

Be sure to assign it a name, otherwise it will just print it out, and not store it in R's environment!
`r qend()`
`r solbegin(show=SHOW_SOLS)`
```{r eval=FALSE}
pwords <- read_csv("....")
```
`r solend()`

---

`r qbegin()`
Look at the 90th entry of the data, using the square brackets. 
`r qend()`
`r solbegin(show=SHOW_SOLS)`
```{r}
# from the pwords data, show the 90th row, and all columns
pwords[90, ]
```
`r solend()`

---

`r qbegin()`
Show the 1st to 20th rows, and the _password_ variable.
`r qend()`
`r solbegin(show=SHOW_SOLS)`
These will all do the same thing:
```{r eval=FALSE}
pwords[c(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20), "password"]
pwords[1:20, "password"]
pwords[1:20, 2]
```
```{r echo=FALSE}
pwords[1:20, 2]
```
`r solend()`

---

`r qbegin()`
Is the _type_ variable being treated as categorical by R? Check using the `is.factor()` function.  
  
If it is not, then make it a factor. 
`r qend()`
`r solbegin(show=SHOW_SOLS)`
```{r}
is.factor(pwords$type)

pwords$type <- as.factor(pwords$type)
```
`r solend()`

---

`r qbegin()`
What __levels__ does the _type_ variable have?
`r qend()`
`r solbegin(show=SHOW_SOLS)`
```{r}
levels(pwords$type)
```
`r solend()`

---
  
`r qbegin()`
Show all the data for passwords categorised as "fluffy". Assign them to a new object called _fluffy_passwords_
`r qend()`
`r solbegin(show=SHOW_SOLS)`
```{r}
# "In the pwords dataframe, give me all the rows for which the
# condition pwords$type=="fluffy" is TRUE, and give me all the columns."
# assign them as a new object called "fluffy_passwords"
fluffy_passwords <- pwords[pwords$type=="fluffy", ]
```

We can now look at our new object by printing it:
```{r}
fluffy_passwords
```

`r solend()`


## Glossary


+ data cleaning
+ continuous
+ count
+ categorical
+ factor
+ level

+ ordinal



| Symbol |  Description| Example |
|--:|--:|--:|
|`[]`|  used to extract the 1st, 2nd, ... $i^{th}$ elements in a set of numbers | `myvector[3]` |
|`$`|  used to extract a named column from a dataframe  |  `mydata$age_variable` |

Not                       | `!`                   | !(1==1)          | FALSE
Or                        | `|`                   | (1==1) | (1==2)  | TRUE
And                       | `&`                   | (1==1) & (1==2)  | FALSE
